---
layout: default
title: PWA(Progressive Web App)
parent: 웹으로 Desktop 앱 만들기
nav_order: 1
tags:
    - pwa
    - desktop app
    - react
---

# PWA(Progressive Web App)로 Desktop 앱 만들기
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---
# Introduction
PWA는 웹 앱을 생성하는 기능을 제공한다. 이전까지 웹으로 제품을 만들었으나 앱으로 제공되면 설치에 더 용이할 것 같다는 니즈가 있었고, 이를 위해 네이티브 앱을 다시 만드는 것이 아닌 간단하게 앱 형태로 감쌀 수 있는 PWA를 도입하기로 결정하였다.
아래에 간단하게 신규/기존 프로젝트에 PWA를 도입하는 방법을 작성하였다.


# Setting

## Install PWA App

### 1. Quick Start: template 사용(프로젝트 초기 생성시)

```bash
npx create-react-app my-app --template pwa-typescript
```

웹 실행시 페이지 설치 아이콘이 나타나지 않을 수 있음. 배포하지 않으면 앱이 제대로 동작하지 않는 문제가 생기는 것 같아보임 → http-server를 설치하여 확인용으로 앱 설치 가능

참고) [https://blog.bitsrc.io/how-to-build-a-react-progressive-web-application-pwa-b5b897df2f0a](https://blog.bitsrc.io/how-to-build-a-react-progressive-web-application-pwa-b5b897df2f0a)

http-server 설치

```bash
yarn add -D http-server
```

build

```bash
yarn build
```

package.json에 script 추가

```bash
"scripts": {
    ...
    "start-sw": "http-server ./build"
  },
```

참고) 브라우저들(chrome, samsung internet, safari)에서 앱 설치하는 방식 소개

[https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Installing](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Installing)

### 2. Integration: 기존 프로젝트에 PWA 도입

**Web Manifest**

- lists all the information about the website in a JSON format
- app 설치 단계에서 브라우저가 정상적으로 web app을 만들어낼 수 있도록 하기 위함이다
- manifest.json
    
    ```json
    // src/manifest.json
    {
      "short_name": "React App",
      "name": "Create React App Sample",
      "icons": [
        {
          "src": "favicon.ico",
          "sizes": "64x64 32x32 24x24 16x16",
          "type": "image/x-icon"
        },
        {
          "src": "logo192.png",
          "type": "image/png",
          "sizes": "192x192"
        },
        {
          "src": "logo512.png",
          "type": "image/png",
          "sizes": "512x512"
        }
      ],
      "start_url": ".",
      "display": "standalone",
      "theme_color": "#000000",
      "background_color": "#ffffff"
    }
    ```
    
- display 속성은 아래와 같다.
    - fullscreen : 앱이 열릴 때 전체 화면을 차지하도록 허용한다(상단의 bar까지는 없어지지 않는 것 같다)
    - standalone : 브라우저의 요소들을 보이지 않게 하여 앱이 네이티브 어플리케이션처럼 보이게 한다
    - minimal-ui : 크롬 모바일에서만 동작하며 브라우저 컨트롤을 일부 제공한다
    - browser : 앱이 브라우저 환경의 경험과 동일하게 표현된다

**Web Site/Browse**

- 신뢰 가능한 사이트에서만 PWA를 릴리즈할 수 있다
- http-server를 설치하거나 배포하여 앱을 설치할 수 있도록 해야한다

**App icon**

- 아이콘이 대부분 png로 되어있었다
- 크기에 따라 서로 다른 png를 적용하는 것으로 보인다
- 사용 환경에 따라 크기를 확인하여 아이콘을 만들 필요가 있어 보였다

**Service Worker**

- chromium 기반의 브라우저에서는 필요함. Firefox에서는 없어도 되긴하지만 호환성을 위해 작성한다
- src/service-worker.ts
    
    ```tsx
    // src/service-worker.ts
    
    /// <reference lib="webworker" />
    /* eslint-disable no-restricted-globals */
    
    // This service worker can be customized!
    // See https://developers.google.com/web/tools/workbox/modules
    // for the list of available Workbox modules, or add any other
    // code you'd like.
    // You can also remove this file if you'd prefer not to use a
    // service worker, and the Workbox build step will be skipped.
    
    import { clientsClaim } from "workbox-core";
    import { ExpirationPlugin } from "workbox-expiration";
    import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
    import { registerRoute } from "workbox-routing";
    import { StaleWhileRevalidate } from "workbox-strategies";
    
    declare const self: ServiceWorkerGlobalScope;
    
    clientsClaim();
    
    // Precache all of the assets generated by your build process.
    // Their URLs are injected into the manifest variable below.
    // This variable must be present somewhere in your service worker file,
    // even if you decide not to use precaching. See https://cra.link/PWA
    precacheAndRoute(self.__WB_MANIFEST);
    
    // Set up App Shell-style routing, so that all navigation requests
    // are fulfilled with your index.html shell. Learn more at
    // https://developers.google.com/web/fundamentals/architecture/app-shell
    const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
    registerRoute(
      // Return false to exempt requests from being fulfilled by index.html.
      ({ request, url }: { request: Request; url: URL }) => {
        // If this isn't a navigation, skip.
        if (request.mode !== "navigate") {
          return false;
        }
    
        // If this is a URL that starts with /_, skip.
        if (url.pathname.startsWith("/_")) {
          return false;
        }
    
        // If this looks like a URL for a resource, because it contains
        // a file extension, skip.
        if (url.pathname.match(fileExtensionRegexp)) {
          return false;
        }
    
        // Return true to signal that we want to use the handler.
        return true;
      },
      createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
    );
    
    // An example runtime caching route for requests that aren't handled by the
    // precache, in this case same-origin .png requests like those from in public/
    registerRoute(
      // Add in any other file extensions or routing criteria as needed.
      ({ url }) => url.origin === self.location.origin && url.pathname.endsWith(".png"),
      // Customize this strategy as needed, e.g., by changing to CacheFirst.
      new StaleWhileRevalidate({
        cacheName: "images",
        plugins: [
          // Ensure that once this runtime cache reaches a maximum size the
          // least-recently used images are removed.
          new ExpirationPlugin({ maxEntries: 50 }),
        ],
      })
    );
    
    // This allows the web app to trigger skipWaiting via
    // registration.waiting.postMessage({type: 'SKIP_WAITING'})
    self.addEventListener("message", (event) => {
      if (event.data && event.data.type === "SKIP_WAITING") {
        self.skipWaiting();
      }
    });
    
    // Any other custom service worker logic can go here.
    ```
    

**ServiceWorkerRegistration**

Registeration/UnRegisteration

- src/serviceWorkerRegistration.ts
    
    ```tsx
    // src/serviceWorkerRegistration.ts
    
    // This optional code is used to register a service worker.
    // register() is not called by default.
    
    // This lets the app load faster on subsequent visits in production, and gives
    // it offline capabilities. However, it also means that developers (and users)
    // will only see deployed updates on subsequent visits to a page, after all the
    // existing tabs open on the page have been closed, since previously cached
    // resources are updated in the background.
    
    // To learn more about the benefits of this model and instructions on how to
    // opt-in, read https://cra.link/PWA
    
    const isLocalhost = Boolean(
      window.location.hostname === "localhost" ||
        // [::1] is the IPv6 localhost address.
        window.location.hostname === "[::1]" ||
        // 127.0.0.0/8 are considered localhost for IPv4.
        window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
    );
    
    type Config = {
      onSuccess?: (registration: ServiceWorkerRegistration) => void;
      onUpdate?: (registration: ServiceWorkerRegistration) => void;
    };
    
    export function register(config?: Config) {
      if (process.env.NODE_ENV === "production" && "serviceWorker" in navigator) {
        // The URL constructor is available in all browsers that support SW.
        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);
        if (publicUrl.origin !== window.location.origin) {
          // Our service worker won't work if PUBLIC_URL is on a different origin
          // from what our page is served on. This might happen if a CDN is used to
          // serve assets; see https://github.com/facebook/create-react-app/issues/2374
          return;
        }
    
        window.addEventListener("load", () => {
          const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;
    
          if (isLocalhost) {
            // This is running on localhost. Let's check if a service worker still exists or not.
            checkValidServiceWorker(swUrl, config);
    
            // Add some additional logging to localhost, pointing developers to the
            // service worker/PWA documentation.
            navigator.serviceWorker.ready.then(() => {
              console.log("This web app is being served cache-first by a service " + "worker. To learn more, visit https://cra.link/PWA");
            });
          } else {
            // Is not localhost. Just register service worker
            registerValidSW(swUrl, config);
          }
        });
      }
    }
    
    function registerValidSW(swUrl: string, config?: Config) {
      navigator.serviceWorker
        .register(swUrl)
        .then((registration) => {
          registration.onupdatefound = () => {
            const installingWorker = registration.installing;
            if (installingWorker == null) {
              return;
            }
            installingWorker.onstatechange = () => {
              if (installingWorker.state === "installed") {
                if (navigator.serviceWorker.controller) {
                  // At this point, the updated precached content has been fetched,
                  // but the previous service worker will still serve the older
                  // content until all client tabs are closed.
                  console.log("New content is available and will be used when all " + "tabs for this page are closed. See https://cra.link/PWA.");
    
                  // Execute callback
                  if (config && config.onUpdate) {
                    config.onUpdate(registration);
                  }
                } else {
                  // At this point, everything has been precached.
                  // It's the perfect time to display a
                  // "Content is cached for offline use." message.
                  console.log("Content is cached for offline use.");
    
                  // Execute callback
                  if (config && config.onSuccess) {
                    config.onSuccess(registration);
                  }
                }
              }
            };
          };
        })
        .catch((error) => {
          console.error("Error during service worker registration:", error);
        });
    }
    
    function checkValidServiceWorker(swUrl: string, config?: Config) {
      // Check if the service worker can be found. If it can't reload the page.
      fetch(swUrl, {
        headers: { "Service-Worker": "script" },
      })
        .then((response) => {
          // Ensure service worker exists, and that we really are getting a JS file.
          const contentType = response.headers.get("content-type");
          if (response.status === 404 || (contentType != null && contentType.indexOf("javascript") === -1)) {
            // No service worker found. Probably a different app. Reload the page.
            navigator.serviceWorker.ready.then((registration) => {
              registration.unregister().then(() => {
                window.location.reload();
              });
            });
          } else {
            // Service worker found. Proceed as normal.
            registerValidSW(swUrl, config);
          }
        })
        .catch(() => {
          console.log("No internet connection found. App is running in offline mode.");
        });
    }
    
    export function unregister() {
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.ready
          .then((registration) => {
            registration.unregister();
          })
          .catch((error) => {
            console.error(error.message);
          });
      }
    }
    ```
    

참고) Service-Worker

[https://floydkim.github.io/2019-05-24-PWA알못들을-위한-Progressive-Web-App-설명서/](https://floydkim.github.io/2019-05-24-PWA%EC%95%8C%EB%AA%BB%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-Progressive-Web-App-%EC%84%A4%EB%AA%85%EC%84%9C/)

## Uninstall PWA App

[https://browserhow.com/how-to-uninstall-chrome-app-pwa-from-chrome-browser/](https://browserhow.com/how-to-uninstall-chrome-app-pwa-from-chrome-browser/)

[https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)

